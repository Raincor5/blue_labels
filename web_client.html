<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced YOLO+OCR Pipeline v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header .version {
            font-size: 1.2rem;
            background: linear-gradient(45deg, #ffd700, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .card h2 {
            margin-bottom: 20px;
            color: #2a5298;
            font-size: 1.4rem;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        /* Connection Panel */
        .connection-panel {
            margin-bottom: 20px;
        }

        .connection-form {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .connection-form input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            text-decoration: none;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #757575 0%, #9e9e9e 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 15px;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
            opacity: 0;
            width: 1px;
            height: 1px;
        }

        /* Display Area */
        .display-area {
            text-align: center;
        }

        .image-container {
            position: relative;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .image-container.has-image {
            border: none;
            background: transparent;
        }

        .display-image {
            max-width: 100%;
            max-height: 600px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .placeholder-text {
            color: #6c757d;
            font-size: 1.1rem;
        }

        /* Performance Metrics */
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Enhanced Results Panel */
        .results-tabs {
            display: flex;
            margin-bottom: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 4px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .tab-btn.active {
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Processing Steps Visualization */
        .processing-steps {
            margin-bottom: 20px;
        }

        .detection-processing {
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .detection-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .detection-steps {
            padding: 15px;
            background: #fafafa;
            display: none;
        }

        .detection-steps.expanded {
            display: block;
        }

        .step-category {
            margin-bottom: 20px;
        }

        .step-category-title {
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e0e0e0;
        }

        .step-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .step-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .step-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .step-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            cursor: pointer;
        }

        .step-info {
            padding: 10px;
        }

        .step-name {
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .step-description {
            font-size: 0.8rem;
            color: #666;
            line-height: 1.3;
        }

        .step-params {
            font-size: 0.7rem;
            color: #888;
            margin-top: 5px;
            font-family: monospace;
        }

        .timing-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
        }

        .timing-item {
            text-align: center;
        }

        .timing-value {
            font-weight: bold;
            color: #2a5298;
        }

        .timing-label {
            font-size: 0.8rem;
            color: #666;
        }

        /* Image Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            max-height: 90%;
        }

        .modal-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 25px;
            color: #ffffff;
            font-size: 35px;
            font-weight: bold;
            cursor: pointer;
        }

        .modal-close:hover {
            opacity: 0.7;
        }

        .modal-info {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            margin-top: 10px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        /* OCR Results */
        .ocr-results {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .detection-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #2a5298;
        }

        .detection-header-ocr {
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 10px;
        }

        .ocr-text {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 10px;
            margin: 8px 0;
            font-family: monospace;
        }

        .confidence {
            font-size: 0.9rem;
            color: #666;
            float: right;
        }

        /* Logs */
        .logs {
            max-height: 300px;
            overflow-y: auto;
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-timestamp {
            color: #a0aec0;
        }

        .log-error {
            color: #fed7d7;
        }

        .log-success {
            color: #9ae6b4;
        }

        /* Settings */
        .settings-group {
            margin-bottom: 20px;
        }

        .settings-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2a5298;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
        }

        /* Webcam */
        .webcam-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .webcam-select {
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }

        .webcam-video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            display: none;
        }

        /* New Feature Badges */
        .new-feature {
            background: linear-gradient(45deg, #ff6b6b, #ffd700);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 10px;
        }

        /* Step Count Badge */
        .step-count {
            background: #28a745;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        /* Processing Pipeline Grid */
        .pipeline-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Debug Info */
        .debug-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .debug-toggle {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .debug-content {
            display: none;
            font-family: monospace;
            font-size: 0.8rem;
            white-space: pre-wrap;
            background: #2d3748;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }

        .debug-content.expanded {
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .step-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .connection-form {
                flex-direction: column;
            }
            
            .connection-form input {
                min-width: auto;
            }
            
            .controls {
                justify-content: center;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            
            .metrics {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .step-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Animations */
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Safari-specific styles */
        .webcam-permission-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }

        .safari-notice {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 Enhanced YOLO+OCR Pipeline</h1>
            <div class="version">Version 2.0 - Linear Transformations & Step Visualization</div>
            <p>Real-time Object Detection & Text Recognition with Advanced Preprocessing</p>
        </div>

        <!-- Safari compatibility notice -->
        <div id="safariNotice" class="safari-notice" style="display: none;">
            <strong>Safari Users:</strong> 
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Click "Allow" when prompted for camera access</li>
                <li>File uploads require clicking the "Choose File" button</li>
                <li>Ensure you're using HTTPS for webcam features</li>
            </ul>
        </div>

        <div class="main-grid">
            <!-- Main Display Area -->
            <div class="card">
                <h2>📸 Live Detection View <span class="new-feature">Enhanced v2.0</span></h2>
                
                <!-- Connection Status -->
                <div class="connection-panel">
                    <div class="connection-form">
                        <input type="text" id="serverUrl" placeholder="WebSocket Server URL" value="ws://localhost:8000/ws">
                        <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">Connect</button>
                    </div>
                    <div id="connectionStatus" class="status disconnected">
                        🔴 Disconnected
                    </div>
                </div>

                <!-- Webcam permission notice -->
                <div id="webcamPermissionNotice" class="webcam-permission-notice">
                    <strong>Camera Permission Required:</strong><br>
                    Please allow camera access when prompted by your browser. In Safari, you may need to check Safari > Preferences > Websites > Camera.
                </div>

                <!-- Controls -->
                <div class="controls">
                    <div class="file-input-wrapper">
                        <button class="btn btn-secondary" onclick="triggerFileUpload()">📁 Choose Image File</button>
                        <input type="file" id="imageUpload" accept="image/*" onchange="uploadImage(this)">
                    </div>
                    
                    <div class="webcam-controls">
                        <button class="btn btn-success" id="startWebcamBtn" onclick="startWebcam()">📹 Start Camera</button>
                        <button class="btn btn-danger" id="stopWebcamBtn" onclick="stopWebcam()" style="display: none;">⏹️ Stop Camera</button>
                        <button class="btn btn-secondary" onclick="capturePhoto()" id="captureBtn" style="display: none;">📸 Capture</button>
                    </div>
                </div>

                <!-- Webcam Video -->
                <video id="webcamVideo" class="webcam-video" autoplay muted playsinline></video>

                <!-- Image Display -->
                <div class="image-container" id="imageContainer">
                    <div class="placeholder-text">
                        Connect to server and upload an image or start camera
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="fpsValue">0.0</div>
                        <div class="metric-label">FPS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="yoloTime">0</div>
                        <div class="metric-label">YOLO (ms)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="ocrTime">0</div>
                        <div class="metric-label">OCR (ms)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="totalTime">0</div>
                        <div class="metric-label">Total (ms)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="preprocessTime">0</div>
                        <div class="metric-label">Preprocess (ms)</div>
                    </div>
                </div>
            </div>

            <!-- Enhanced Results Panel -->
            <div class="card">
                <h2>📊 Results & Processing Steps <span class="new-feature">New!</span></h2>
                
                <!-- Enhanced Tabs -->
                <div class="results-tabs">
                    <button class="tab-btn active" onclick="switchTab('steps')">🔬 Processing Steps</button>
                    <button class="tab-btn" onclick="switchTab('ocr')">📝 OCR Results</button>
                    <button class="tab-btn" onclick="switchTab('settings')">⚙️ Settings</button>
                    <button class="tab-btn" onclick="switchTab('logs')">📋 Logs</button>
                </div>

                <!-- Processing Steps Tab -->
                <div id="stepsTab" class="tab-content active">
                    <div class="processing-steps" id="processingsteps">
                        <div style="text-align: center; color: #666; padding: 20px;">
                            No processing steps yet. Upload an image or start camera to see the enhanced preprocessing pipeline visualization.
                        </div>
                    </div>
                </div>

                <!-- OCR Results Tab -->
                <div id="ocrTab" class="tab-content">
                    <div class="ocr-results" id="ocrResults">
                        <div style="text-align: center; color: #666; padding: 20px;">
                            No OCR results yet. Upload an image or start camera to begin.
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="clearOCRResults()">🗑️ Clear Results</button>
                        <button class="btn btn-secondary" onclick="exportOCRText()">💾 Export Text</button>
                        <button class="btn btn-secondary" onclick="copyAllText()">📋 Copy All</button>
                    </div>
                </div>

                <!-- Settings Tab -->
                <div id="settingsTab" class="tab-content">
                    <div class="settings-group">
                        <label>YOLO Confidence Threshold:</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="yoloConfidence" min="0.1" max="1.0" step="0.05" value="0.5">
                            <span class="slider-value" id="yoloConfValue">0.50</span>
                        </div>
                    </div>
                    
                    <div class="settings-group">
                        <label>OCR Confidence Threshold:</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="ocrConfidence" min="0.1" max="1.0" step="0.05" value="0.3">
                            <span class="slider-value" id="ocrConfValue">0.30</span>
                        </div>
                    </div>
                    
                    <div class="settings-group">
                        <label>
                            <input type="checkbox" id="enableOCR" checked> Enable OCR Processing
                        </label>
                    </div>
                    
                    <div class="settings-group">
                        <label>
                            <input type="checkbox" id="enablePreprocessing" checked> Enable Enhanced Preprocessing
                        </label>
                    </div>
                    
                    <div class="settings-group">
                        <label>
                            <input type="checkbox" id="enableRotationCorrection" checked> Enable Rotation Correction
                        </label>
                    </div>
                    
                    <div class="settings-group">
                        <label>
                            <input type="checkbox" id="enableDebugMode"> Enable Debug Mode (Step Visualization)
                        </label>
                    </div>
                    
                    <div class="settings-group">
                        <label>OCR Engine Mode:</label>
                        <select id="ocrEngineMode" style="padding: 8px; border: 1px solid #e0e0e0; border-radius: 5px;">
                            <option value="ensemble">Ensemble (EasyOCR + Tesseract + TrOCR)</option>
                            <option value="prefer_trocr">Prefer TrOCR (plus others)</option>
                            <option value="trocr">TrOCR only</option>
                            <option value="easyocr">EasyOCR only</option>
                            <option value="tesseract">Tesseract only</option>
                        </select>
                    </div>

                    <div class="settings-group">
                        <label>
                            <input type="checkbox" id="enableMultiscaleOcr" checked> Enable Multi-Scale OCR
                        </label>
                    </div>

                    <div class="settings-group">
                        <label>OCR Scales (comma-separated):</label>
                        <input id="ocrScales" type="text" value="0.5,1.0,1.5,2.0" style="width: 100%; padding: 8px; border: 1px solid #e0e0e0; border-radius: 5px;" />
                    </div>

                    <div class="settings-group">
                        <label>
                            <input type="checkbox" id="enableSuperres"> Enable Super-Resolution (if available)
                        </label>
                    </div>
                    
                    <div class="settings-group">
                        <label>Capture Interval (seconds):</label>
                        <div class="slider-container">
                            <input type="range" class="slider" id="captureInterval" min="1" max="10" step="1" value="3">
                            <span class="slider-value" id="captureIntervalValue">3</span>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <button class="btn btn-primary" onclick="updateServerSettings()">💾 Update Server Settings</button>
                        <button class="btn btn-secondary" style="margin-left: 10px;" onclick="loadServerSettings()">🔄 Load Server Settings</button>
                    </div>
                </div>

                <!-- Logs Tab -->
                <div id="logsTab" class="tab-content">
                    <div class="logs" id="logsContainer">
                        <div class="log-entry">
                            <span class="log-timestamp">[System]</span> Enhanced web client v2.0 initialized
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="clearLogs()">🗑️ Clear Logs</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Processing Pipeline Overview -->
        <div class="card pipeline-grid">
            <h2>🔄 Enhanced Processing Pipeline Overview</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div class="metric" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    <div class="metric-label">Stage 1: YOLO Detection</div>
                    <div style="font-size: 0.9rem; margin-top: 5px;">Oriented Bounding Boxes</div>
                </div>
                <div class="metric" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">
                    <div class="metric-label">Stage 2: Perspective Correction</div>
                    <div style="font-size: 0.9rem; margin-top: 5px;">Linear Transformations</div>
                </div>
                <div class="metric" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    <div class="metric-label">Stage 3: Boundary Refinement</div>
                    <div style="font-size: 0.9rem; margin-top: 5px;">Edge Detection & Contours</div>
                </div>
                <div class="metric" style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);">
                    <div class="metric-label">Stage 4: Image Enhancement</div>
                    <div style="font-size: 0.9rem; margin-top: 5px;">CLAHE & Filtering</div>
                </div>
                <div class="metric" style="background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);">
                    <div class="metric-label">Stage 5: Rotation Correction</div>
                    <div style="font-size: 0.9rem; margin-top: 5px;">Hough Line Transform</div>
                </div>
                <div class="metric" style="background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);">
                    <div class="metric-label">Stage 6: Multi-Engine OCR</div>
                    <div style="font-size: 0.9rem; margin-top: 5px;">EasyOCR + Tesseract</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div id="imageModal" class="modal" onclick="closeModal()">
        <span class="modal-close" onclick="closeModal()">&times;</span>
        <div class="modal-content">
            <img id="modalImage" class="modal-image" src="" alt="">
            <div id="modalInfo" class="modal-info">
                <div id="modalTitle" style="font-weight: bold; margin-bottom: 5px;"></div>
                <div id="modalDescription" style="margin-bottom: 10px;"></div>
                <div id="modalParams" style="font-size: 0.9rem; color: #666;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let websocket = null;
        let isConnected = false;
        let webcamStream = null;
        let isWebcamRunning = false;
        let captureInterval = null;
        let fpsCounter = 0;
        let fpsStartTime = Date.now();
        let webcamVideo = null;
        let currentProcessingSteps = {};

        // Safari detection
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            updateConnectionUI(false);
            detectBrowser();
            webcamVideo = document.getElementById('webcamVideo');
            logMessage('🚀 Enhanced YOLO+OCR Pipeline v2.0 client loaded with step visualization support');
        });

        function detectBrowser() {
            if (isSafari) {
                document.getElementById('safariNotice').style.display = 'block';
                logMessage('Safari detected - enhanced compatibility mode enabled', 'info');
            }
        }

        function setupEventListeners() {
            // Slider updates
            document.getElementById('yoloConfidence').addEventListener('input', function() {
                document.getElementById('yoloConfValue').textContent = parseFloat(this.value).toFixed(2);
            });

            document.getElementById('ocrConfidence').addEventListener('input', function() {
                document.getElementById('ocrConfValue').textContent = parseFloat(this.value).toFixed(2);
            });

            document.getElementById('captureInterval').addEventListener('input', function() {
                document.getElementById('captureIntervalValue').textContent = this.value;
                if (isWebcamRunning) {
                    restartCapture();
                }
            });

            // Enter key for connection
            document.getElementById('serverUrl').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    toggleConnection();
                }
            });

            // File input change handler
            document.getElementById('imageUpload').addEventListener('change', function(e) {
                if (e.target.files && e.target.files[0]) {
                    uploadImage(this);
                }
            });

            // Modal close on ESC key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                }
            });
        }

        function triggerFileUpload() {
            const fileInput = document.getElementById('imageUpload');
            fileInput.click();
        }

        function toggleConnection() {
            if (isConnected) {
                disconnect();
            } else {
                connect();
            }
        }

        function connect() {
            const url = document.getElementById('serverUrl').value;
            
            try {
                websocket = new WebSocket(url);
                
                websocket.onopen = function() {
                    isConnected = true;
                    updateConnectionUI(true);
                    logMessage('Connected to Enhanced YOLO+OCR Pipeline Server v2.0', 'success');
                    // Load server settings on connect
                    loadServerSettings();
                };

                websocket.onmessage = function(event) {
                    handleWebSocketMessage(event.data);
                };

                websocket.onclose = function() {
                    isConnected = false;
                    updateConnectionUI(false);
                    logMessage('Disconnected from server', 'error');
                };

                websocket.onerror = function(error) {
                    logMessage('WebSocket error: ' + error.message, 'error');
                };

            } catch (error) {
                logMessage('Connection failed: ' + error.message, 'error');
            }
        }

        function disconnect() {
            if (websocket) {
                websocket.close();
                websocket = null;
            }
            stopWebcam();
            isConnected = false;
            updateConnectionUI(false);
        }

        function updateConnectionUI(connected) {
            const status = document.getElementById('connectionStatus');
            const btn = document.getElementById('connectBtn');

            if (connected) {
                status.className = 'status connected';
                status.innerHTML = '🟢 Connected';
                btn.textContent = 'Disconnect';
                btn.className = 'btn btn-danger';
            } else {
                status.className = 'status disconnected';
                status.innerHTML = '🔴 Disconnected';
                btn.textContent = 'Connect';
                btn.className = 'btn btn-primary';
            }
        }

        function handleWebSocketMessage(data) {
            try {
                const message = JSON.parse(data);
                
                switch (message.type) {
                    case 'pipeline_result':
                        handlePipelineResult(message);
                        break;
                    case 'info':
                        logMessage('Server: ' + message.message);
                        if (message.features) {
                            logMessage('✨ Server features: ' + Object.keys(message.features).join(', '), 'info');
                        }
                        break;
                    case 'error':
                        logMessage('Server error: ' + message.message, 'error');
                        break;
                    case 'pong':
                        logMessage('Server pong received - pipeline v' + (message.server_info?.version || '2.0'));
                        if (message.server_info) {
                            logMessage('🔧 Pipeline features: ' + Object.entries(message.server_info).filter(([k,v]) => v === true).map(([k]) => k).join(', '));
                        }
                        break;
                    default:
                        logMessage('Unknown message type: ' + message.type);
                }
            } catch (error) {
                logMessage('Failed to parse server message: ' + error.message, 'error');
            }
        }

        function handlePipelineResult(result) {
            // Update performance metrics
            const timing = result.timing || {};
            updateMetrics(0, timing.yolo_ms || 0, timing.ocr_ms || 0, timing.total_ms || 0, timing.preprocessing_ms || 0);

            // Display annotated image
            if (result.annotated_image) {
                displayImage('data:image/jpeg;base64,' + result.annotated_image);
            }

            // Update OCR results
            updateOCRResults(result.yolo_detections || [], result.ocr_results || {});

            // Update processing steps visualization
            updateProcessingSteps(result.processing_steps || {}, result.yolo_detections || []);

            const detectionCount = result.yolo_detections?.length || 0;
            const ocrCount = Object.keys(result.ocr_results || {}).length;
            const processingEnabled = result.settings?.preprocessing_enabled ? 'ON' : 'OFF';
            const rotationEnabled = result.settings?.rotation_correction_enabled ? 'ON' : 'OFF';
            
            logMessage(`✅ Processed: ${detectionCount} detections, ${ocrCount} OCR results | Preprocessing: ${processingEnabled}, Rotation: ${rotationEnabled}`);
        }

        function updateMetrics(fps, yoloMs, ocrMs, totalMs, preprocessMs) {
            if (fps > 0) document.getElementById('fpsValue').textContent = fps.toFixed(1);
            if (yoloMs > 0) document.getElementById('yoloTime').textContent = Math.round(yoloMs);
            if (ocrMs > 0) document.getElementById('ocrTime').textContent = Math.round(ocrMs);
            if (totalMs > 0) document.getElementById('totalTime').textContent = Math.round(totalMs);
            if (preprocessMs > 0) document.getElementById('preprocessTime').textContent = Math.round(preprocessMs);
        }

        function updateProcessingSteps(processingSteps, detections) {
            const container = document.getElementById('processingsteps');
            currentProcessingSteps = processingSteps;
            
            // Debug logging
            console.log('🔍 updateProcessingSteps called with:', {
                processingSteps: processingSteps,
                detections: detections,
                processingStepsKeys: processingSteps ? Object.keys(processingSteps) : [],
                hasStepImages: processingSteps && Object.keys(processingSteps).some(key => 
                    processingSteps[key] && processingSteps[key].step_images
                )
            });
            
            if (!processingSteps || Object.keys(processingSteps).length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No processing steps available. Enable debug mode in settings for detailed visualization.</div>';
                return;
            }

            let html = '';
            
            Object.entries(processingSteps).forEach(([detectionIdx, stepInfo]) => {
                const detection = detections[parseInt(detectionIdx)] || {};
                const stepCount = (stepInfo.perspective_steps?.length || 0) + 
                                (stepInfo.enhancement_steps?.length || 0) + 
                                (stepInfo.rotation_steps?.length || 0);
                
                html += `
                    <div class="detection-processing fade-in">
                        <div class="detection-header" onclick="toggleDetectionSteps(${detectionIdx})">
                            <span>🎯 Detection ${parseInt(detectionIdx) + 1}: ${detection.class_name || 'Unknown'}</span>
                            <div>
                                <span class="step-count">${stepCount}</span>
                                <span style="margin-left: 10px;">▼</span>
                            </div>
                        </div>
                        <div id="detection-steps-${detectionIdx}" class="detection-steps">
                `;

                // Add timing information
                if (stepInfo.timing) {
                    html += `
                        <div class="timing-info">
                            <div class="timing-item">
                                <div class="timing-value">${(stepInfo.timing.perspective_correction * 1000 || 0).toFixed(1)}ms</div>
                                <div class="timing-label">Perspective</div>
                            </div>
                            <div class="timing-item">
                                <div class="timing-value">${(stepInfo.timing.enhancement * 1000 || 0).toFixed(1)}ms</div>
                                <div class="timing-label">Enhancement</div>
                            </div>
                            <div class="timing-item">
                                <div class="timing-value">${(stepInfo.timing.rotation_correction * 1000 || 0).toFixed(1)}ms</div>
                                <div class="timing-label">Rotation</div>
                            </div>
                            <div class="timing-item">
                                <div class="timing-value">${(stepInfo.timing.ocr * 1000 || 0).toFixed(1)}ms</div>
                                <div class="timing-label">OCR</div>
                            </div>
                        </div>
                    `;
                }

                // Add perspective correction steps
                if (stepInfo.perspective_steps && stepInfo.perspective_steps.length > 0) {
                    html += `
                        <div class="step-category">
                            <div class="step-category-title">🔄 Perspective Correction & Linear Transformations</div>
                            <div class="step-grid">
                    `;
                    stepInfo.perspective_steps.forEach((step, stepIdx) => {
                        html += createStepHTML(step, `perspective_${detectionIdx}_${stepIdx}`, stepInfo.step_images);
                    });
                    html += '</div></div>';
                }

                // Add enhancement steps
                if (stepInfo.enhancement_steps && stepInfo.enhancement_steps.length > 0) {
                    html += `
                        <div class="step-category">
                            <div class="step-category-title">✨ Image Enhancement & Preprocessing</div>
                            <div class="step-grid">
                    `;
                    stepInfo.enhancement_steps.forEach((step, stepIdx) => {
                        html += createStepHTML(step, `enhancement_${detectionIdx}_${stepIdx}`, stepInfo.step_images);
                    });
                    html += '</div></div>';
                }

                // Add rotation correction steps
                if (stepInfo.rotation_steps && stepInfo.rotation_steps.length > 0) {
                    html += `
                        <div class="step-category">
                            <div class="step-category-title">🔄 Rotation Correction & Hough Lines</div>
                            <div class="step-grid">
                    `;
                    stepInfo.rotation_steps.forEach((step, stepIdx) => {
                        html += createStepHTML(step, `rotation_${detectionIdx}_${stepIdx}`, stepInfo.step_images);
                    });
                    html += '</div></div>';
                }

                // Add debug information if available
                if (stepInfo.error) {
                    html += `
                        <div class="debug-info">
                            <strong style="color: #dc3545;">Processing Error:</strong>
                            <div style="color: #dc3545; margin-top: 5px;">${stepInfo.error}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="debug-info">
                            <button class="debug-toggle" onclick="toggleDebugInfo(${detectionIdx})">
                                🔍 Show Technical Details
                            </button>
                            <div id="debug-content-${detectionIdx}" class="debug-content">
${JSON.stringify(stepInfo, null, 2)}
                            </div>
                        </div>
                    `;
                }

                html += '</div></div>';
            });

            if (html === '') {
                html = '<div style="text-align: center; color: #666; padding: 20px;">Processing steps not available. Enable debug mode for detailed visualization.</div>';
            }

            container.innerHTML = html;
        }

        function createStepHTML(step, stepId, stepImages) {
            // Try to find the image with the correct prefix
            let imageSrc = null;
            if (stepImages) {
                // Try different possible key formats
                const possibleKeys = [
                    step.name,  // Direct match
                    `perspective_${step.name}`,  // Perspective prefix
                    `enhancement_${step.name}`,  // Enhancement prefix
                    `rotation_${step.name}`  // Rotation prefix
                ];
                
                // Debug logging
                console.log('🔍 createStepHTML for step:', step.name, 'with stepImages keys:', Object.keys(stepImages || {}));
                
                for (const key of possibleKeys) {
                    if (stepImages[key]) {
                        imageSrc = `data:image/jpeg;base64,${stepImages[key]}`;
                        console.log('✅ Found image for key:', key);
                        break;
                    }
                }
                
                if (!imageSrc) {
                    console.log('❌ No image found for step:', step.name, 'tried keys:', possibleKeys);
                }
            }
            
            let paramsText = '';
            if (step.params && Object.keys(step.params).length > 0) {
                const importantParams = Object.entries(step.params)
                    .filter(([key, value]) => !key.includes('matrix') && !Array.isArray(value))
                    .slice(0, 3)
                    .map(([key, value]) => `${key}: ${typeof value === 'number' ? value.toFixed(2) : value}`)
                    .join(', ');
                if (importantParams) paramsText = importantParams;
            }

            return `
                <div class="step-item">
                    ${imageSrc ? `
                        <img src="${imageSrc}" 
                             alt="${step.name}" 
                             class="step-image"
                             onclick="openModal('${imageSrc}', '${step.name}', '${step.description}', '${paramsText}')"
                             title="Click to enlarge">
                    ` : `
                        <div class="step-image" style="background: linear-gradient(45deg, #f0f0f0, #e0e0e0); display: flex; align-items: center; justify-content: center; color: #666;">
                            📊 ${step.name.replace(/_/g, ' ').toUpperCase()}
                        </div>
                    `}
                    <div class="step-info">
                        <div class="step-name">${step.name.replace(/_/g, ' ').toUpperCase()}</div>
                        <div class="step-description">${step.description}</div>
                        ${paramsText ? `<div class="step-params">${paramsText}</div>` : ''}
                        ${step.image_shape ? `<div class="step-params">Size: ${step.image_shape.join('×')}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function toggleDetectionSteps(detectionIdx) {
            const stepsElement = document.getElementById(`detection-steps-${detectionIdx}`);
            if (stepsElement) {
                stepsElement.classList.toggle('expanded');
                
                // Update arrow direction
                const header = stepsElement.previousElementSibling;
                const arrow = header.querySelector('span:last-child');
                if (arrow) {
                    arrow.textContent = stepsElement.classList.contains('expanded') ? '▲' : '▼';
                }
            }
        }

        function toggleDebugInfo(detectionIdx) {
            const debugContent = document.getElementById(`debug-content-${detectionIdx}`);
            if (debugContent) {
                debugContent.classList.toggle('expanded');
                const button = debugContent.previousElementSibling;
                button.textContent = debugContent.classList.contains('expanded') ? 
                    '🔍 Hide Technical Details' : '🔍 Show Technical Details';
            }
        }

        function openModal(imageSrc, title, description, params) {
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            const modalParams = document.getElementById('modalParams');
            
            modalImage.src = imageSrc;
            modalTitle.textContent = title.replace(/_/g, ' ').toUpperCase();
            modalDescription.textContent = description;
            modalParams.textContent = params;
            
            modal.style.display = 'block';
        }

        function closeModal() {
            const modal = document.getElementById('imageModal');
            modal.style.display = 'none';
        }

        function httpBaseFromWs(url) {
            try {
                const u = new URL(url);
                const scheme = u.protocol === 'wss:' ? 'https:' : 'http:';
                const base = `${scheme}//${u.host}`;
                return base;
            } catch (e) {
                return null;
            }
        }

        async function loadServerSettings() {
            const url = document.getElementById('serverUrl').value;
            const base = httpBaseFromWs(url);
            if (!base) {
                logMessage('Invalid server URL for settings fetch', 'error');
                return;
            }
            try {
                const resp = await fetch(`${base}/settings`);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const s = await resp.json();
                // Populate UI
                document.getElementById('enableOCR').checked = !!s.ocr_enabled;
                document.getElementById('enablePreprocessing').checked = !!s.preprocessing_enabled;
                document.getElementById('enableRotationCorrection').checked = !!s.rotation_correction_enabled;
                document.getElementById('enableDebugMode').checked = !!s.debug_mode;
                if (typeof s.min_confidence === 'number') {
                    document.getElementById('ocrConfidence').value = s.min_confidence;
                    document.getElementById('ocrConfValue').textContent = Number(s.min_confidence).toFixed(2);
                }
                if (typeof s.enable_multiscale_ocr !== 'undefined') {
                    document.getElementById('enableMultiscaleOcr').checked = !!s.enable_multiscale_ocr;
                }
                if (Array.isArray(s.ocr_scales)) {
                    document.getElementById('ocrScales').value = s.ocr_scales.join(',');
                }
                if (typeof s.enable_superres !== 'undefined') {
                    document.getElementById('enableSuperres').checked = !!s.enable_superres;
                }
                if (s.ocr_engine_mode) {
                    document.getElementById('ocrEngineMode').value = s.ocr_engine_mode;
                }
                logMessage('✅ Loaded server settings', 'success');
            } catch (err) {
                logMessage('Failed to load server settings: ' + err.message, 'error');
            }
        }

        async function updateServerSettings() {
            if (!isConnected) {
                logMessage('Not connected to server - cannot update settings', 'error');
                return;
            }

            const url = document.getElementById('serverUrl').value;
            const base = httpBaseFromWs(url);
            if (!base) {
                logMessage('Invalid server URL for settings update', 'error');
                return;
            }

            // Parse scales
            const scales = document.getElementById('ocrScales').value
                .split(',')
                .map(s => parseFloat(s.trim()))
                .filter(s => !isNaN(s));

            const settings = {
                ocr_enabled: document.getElementById('enableOCR').checked,
                preprocessing_enabled: document.getElementById('enablePreprocessing').checked,
                rotation_correction_enabled: document.getElementById('enableRotationCorrection').checked,
                debug_mode: document.getElementById('enableDebugMode').checked,
                min_confidence: parseFloat(document.getElementById('ocrConfidence').value),
                enable_multiscale_ocr: document.getElementById('enableMultiscaleOcr').checked,
                ocr_scales: scales,
                enable_superres: document.getElementById('enableSuperres').checked,
                ocr_engine_mode: document.getElementById('ocrEngineMode').value
            };

            try {
                const resp = await fetch(`${base}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                const updated = await resp.json();
                logMessage('🔧 Server settings updated: ' + JSON.stringify(updated.settings), 'success');
            } catch (err) {
                logMessage('Failed to update server settings: ' + err.message, 'error');
            }
        }

        function updateOCRResults(detections, ocrResults) {
            const container = document.getElementById('ocrResults');
            
            if (detections.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No detections found</div>';
                return;
            }

            let html = '';
            detections.forEach((detection, index) => {
                const ocrData = ocrResults[index] || [];
                
                html += `
                    <div class="detection-item fade-in">
                        <div class="detection-header-ocr">
                            Detection ${index + 1}: ${detection.class_name}
                            <span class="confidence">Confidence: ${(detection.confidence * 100).toFixed(1)}%</span>
                        </div>
                `;

                if (ocrData.length > 0) {
                    ocrData.forEach((ocr, ocrIndex) => {
                        const engine = ocr.engine || 'unknown';
                        const engineBadge = engine === 'easyocr' ? '🤖 EasyOCR' : 
                                          engine === 'tesseract' ? '📝 Tesseract' : 
                                          engine === 'trocr' ? '🔤 TrOCR' : '❓ Unknown';
                        
                        html += `
                            <div class="ocr-text">
                                <strong>Text ${ocrIndex + 1} (${engineBadge}):</strong> "${ocr.text}"
                                <span class="confidence">Confidence: ${(ocr.confidence * 100).toFixed(1)}%</span>
                            </div>
                        `;
                    });
                } else {
                    html += '<div style="color: #666; font-style: italic;">No text detected in this region</div>';
                }

                html += '</div>';
            });

            container.innerHTML = html;
        }

        function displayImage(src) {
            const container = document.getElementById('imageContainer');
            container.innerHTML = `<img src="${src}" alt="Detection Result" class="display-image fade-in">`;
            container.classList.add('has-image');
        }

        function uploadImage(input) {
            if (!isConnected) {
                alert('Please connect to server first');
                return;
            }

            const file = input.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                logMessage('Please select a valid image file', 'error');
                return;
            }

            logMessage(`📤 Loading image: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`, 'info');

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Resize if too large
                    let { width, height } = img;
                    const maxDimension = 1024;
                    
                    if (width > maxDimension || height > maxDimension) {
                        const scale = maxDimension / Math.max(width, height);
                        width *= scale;
                        height *= scale;
                        logMessage(`📏 Resized image: ${img.width}×${img.height} → ${Math.round(width)}×${Math.round(height)}`);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    try {
                        const base64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                        sendImageToServer(base64, `Upload: ${file.name}`);
                    } catch (error) {
                        logMessage('Failed to process image: ' + error.message, 'error');
                    }
                };
                img.onerror = function() {
                    logMessage('Failed to load image file', 'error');
                };
                img.src = e.target.result;
            };
            reader.onerror = function() {
                logMessage('Failed to read file', 'error');
            };
            reader.readAsDataURL(file);
            
            // Reset file input
            input.value = '';
        }

        function startWebcam() {
            if (!isConnected) {
                alert('Please connect to server first');
                return;
            }

            // Show permission notice for Safari
            if (isSafari) {
                document.getElementById('webcamPermissionNotice').style.display = 'block';
            }

            const constraints = {
                video: {
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: 'environment' // Prefer back camera on mobile
                }
            };

            navigator.mediaDevices.getUserMedia(constraints)
                .then(stream => {
                    webcamStream = stream;
                    webcamVideo.srcObject = stream;
                    webcamVideo.style.display = 'block';
                    
                    // Hide permission notice
                    document.getElementById('webcamPermissionNotice').style.display = 'none';
                    
                    // Update UI
                    document.getElementById('startWebcamBtn').style.display = 'none';
                    document.getElementById('stopWebcamBtn').style.display = 'inline-block';
                    document.getElementById('captureBtn').style.display = 'inline-block';
                    
                    isWebcamRunning = true;
                    startAutoCapture();
                    
                    logMessage('📹 Camera started successfully - auto capture enabled', 'success');
                })
                .catch(error => {
                    console.error('Camera access error:', error);
                    let errorMsg = 'Failed to access camera: ';
                    
                    switch(error.name) {
                        case 'NotAllowedError':
                            errorMsg += 'Permission denied. Please allow camera access.';
                            if (isSafari) {
                                errorMsg += ' Check Safari > Preferences > Websites > Camera.';
                            }
                            break;
                        case 'NotFoundError':
                            errorMsg += 'No camera found on this device.';
                            break;
                        case 'NotReadableError':
                            errorMsg += 'Camera is being used by another application.';
                            break;
                        case 'OverconstrainedError':
                            errorMsg += 'Camera constraints cannot be satisfied.';
                            break;
                        default:
                            errorMsg += error.message || 'Unknown error occurred.';
                    }
                    
                    logMessage(errorMsg, 'error');
                    
                    // Hide permission notice on error
                    document.getElementById('webcamPermissionNotice').style.display = 'none';
                });
        }

        function stopWebcam() {
            isWebcamRunning = false;
            
            if (captureInterval) {
                clearInterval(captureInterval);
                captureInterval = null;
            }
            
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => {
                    track.stop();
                });
                webcamStream = null;
            }
            
            webcamVideo.style.display = 'none';
            webcamVideo.srcObject = null;
            
            // Update UI
            document.getElementById('startWebcamBtn').style.display = 'inline-block';
            document.getElementById('stopWebcamBtn').style.display = 'none';
            document.getElementById('captureBtn').style.display = 'none';
            
            logMessage('📹 Camera stopped', 'info');
        }

        function startAutoCapture() {
            if (captureInterval) {
                clearInterval(captureInterval);
            }
            
            const interval = parseInt(document.getElementById('captureInterval').value) * 1000;
            
            captureInterval = setInterval(() => {
                if (isWebcamRunning && webcamVideo && !webcamVideo.paused) {
                    capturePhoto();
                }
            }, interval);
        }

        function restartCapture() {
            if (isWebcamRunning) {
                startAutoCapture();
                logMessage('🔄 Capture interval updated', 'info');
            }
        }

        function capturePhoto() {
            if (!webcamVideo || webcamVideo.paused) {
                logMessage('No video stream available', 'error');
                return;
            }

            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = webcamVideo.videoWidth;
                canvas.height = webcamVideo.videoHeight;
                
                ctx.drawImage(webcamVideo, 0, 0);
                
                const base64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                sendImageToServer(base64, 'Camera');
                
                // Calculate FPS
                fpsCounter++;
                if (fpsCounter >= 10) {
                    const fps = fpsCounter / ((Date.now() - fpsStartTime) / 1000);
                    updateMetrics(fps, 0, 0, 0, 0);
                    fpsCounter = 0;
                    fpsStartTime = Date.now();
                }
                
            } catch (error) {
                logMessage('Failed to capture photo: ' + error.message, 'error');
            }
        }

        function sendImageToServer(base64Data, source) {
            if (!websocket || !isConnected) {
                logMessage('Not connected to server', 'error');
                return;
            }

            try {
                websocket.send(base64Data);
                logMessage(`🚀 Sent image from ${source}`, 'info');
            } catch (error) {
                logMessage('Failed to send image: ' + error.message, 'error');
            }
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        function clearOCRResults() {
            document.getElementById('ocrResults').innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">OCR results cleared</div>';
            logMessage('OCR results cleared');
        }

        function exportOCRText() {
            const results = document.getElementById('ocrResults');
            const textElements = results.querySelectorAll('.ocr-text');
            
            let exportText = '=== Enhanced YOLO+OCR Pipeline v2.0 Export ===\n';
            exportText += `Timestamp: ${new Date().toLocaleString()}\n`;
            exportText += `Total OCR Results: ${textElements.length}\n\n`;
            
            textElements.forEach((element, index) => {
                const text = element.textContent.replace(/OCR Confidence:.*/, '').trim();
                const confidence = element.textContent.match(/Confidence: ([\d.]+)%/);
                const engine = element.textContent.match(/\((.*?)\)/);
                
                exportText += `${index + 1}. ${text}\n`;
                if (confidence) exportText += `   Confidence: ${confidence[1]}%\n`;
                if (engine) exportText += `   Engine: ${engine[1]}\n`;
                exportText += '\n';
            });
            
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `enhanced_ocr_results_${Date.now()}.txt`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            logMessage('📄 OCR text exported with metadata', 'success');
        }

        function copyAllText() {
            const results = document.getElementById('ocrResults');
            const textElements = results.querySelectorAll('.ocr-text');
            
            let allText = '';
            textElements.forEach(element => {
                const text = element.textContent.replace(/Text \d+.*?: "|OCR Confidence:.*/, '').replace(/\(.*?\): "/, '').trim();
                if (text && text !== '"') allText += text + '\n';
            });
            
            if (allText) {
                // Modern clipboard API with fallback
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(allText).then(() => {
                        logMessage('📋 Text copied to clipboard', 'success');
                    }).catch(() => {
                        fallbackCopyTextToClipboard(allText);
                    });
                } else {
                    fallbackCopyTextToClipboard(allText);
                }
            } else {
                logMessage('No text to copy', 'error');
            }
        }

        function fallbackCopyTextToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-999999px';
            textarea.style.top = '-999999px';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    logMessage('📋 Text copied to clipboard', 'success');
                } else {
                    logMessage('Failed to copy text', 'error');
                }
            } catch (err) {
                logMessage('Copy not supported', 'error');
            }
            
            document.body.removeChild(textarea);
        }

        function clearLogs() {
            document.getElementById('logsContainer').innerHTML = '<div class="log-entry"><span class="log-timestamp">[System]</span> Logs cleared</div>';
        }

        function logMessage(message, type = 'info') {
            const container = document.getElementById('logsContainer');
            const timestamp = new Date().toLocaleTimeString();
            
            let className = 'log-entry';
            let icon = 'ℹ️';
            
            switch (type) {
                case 'error':
                    className += ' log-error';
                    icon = '❌';
                    break;
                case 'success':
                    className += ' log-success';
                    icon = '✅';
                    break;
                default:
                    icon = 'ℹ️';
            }
            
            const logEntry = document.createElement('div');
            logEntry.className = className;
            logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> ${icon} ${message}`;
            
            container.appendChild(logEntry);
            container.scrollTop = container.scrollHeight;
            
            // Keep only last 100 log entries
            const entries = container.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                entries[0].remove();
            }
        }

        // Enhanced drag and drop support for images
        let dragCounter = 0;

        document.addEventListener('dragenter', function(e) {
            e.preventDefault();
            dragCounter++;
            const container = document.getElementById('imageContainer');
            container.style.borderColor = '#2a5298';
            container.style.backgroundColor = 'rgba(42, 82, 152, 0.1)';
            container.style.transform = 'scale(1.02)';
        });

        document.addEventListener('dragleave', function(e) {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                const container = document.getElementById('imageContainer');
                container.style.borderColor = '#dee2e6';
                container.style.backgroundColor = '#f8f9fa';
                container.style.transform = 'scale(1)';
            }
        });

        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function(e) {
            e.preventDefault();
            dragCounter = 0;
            
            const container = document.getElementById('imageContainer');
            container.style.borderColor = '#dee2e6';
            container.style.backgroundColor = '#f8f9fa';
            container.style.transform = 'scale(1)';
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type.startsWith('image/')) {
                const input = document.getElementById('imageUpload');
                input.files = files;
                uploadImage(input);
                logMessage('📁 Image dropped and uploaded', 'success');
            } else {
                logMessage('Please drop a valid image file', 'error');
            }
        });

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Only handle shortcuts when not typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            // Ctrl/Cmd + U for upload
            if ((e.ctrlKey || e.metaKey) && e.key === 'u') {
                e.preventDefault();
                triggerFileUpload();
            }
            
            // Ctrl/Cmd + W for webcam toggle
            if ((e.ctrlKey || e.metaKey) && e.key === 'w') {
                e.preventDefault();
                if (isWebcamRunning) {
                    stopWebcam();
                } else {
                    startWebcam();
                }
            }
            
            // Space for connect/disconnect
            if (e.key === ' ') {
                e.preventDefault();
                toggleConnection();
            }
            
            // C for capture photo
            if (e.key === 'c' && isWebcamRunning) {
                e.preventDefault();
                capturePhoto();
            }

            // Tab switching shortcuts (1-4)
            if (e.key >= '1' && e.key <= '4') {
                e.preventDefault();
                const tabs = ['steps', 'ocr', 'settings', 'logs'];
                switchTab(tabs[parseInt(e.key) - 1]);
            }

            // ESC to close modal
            if (e.key === 'Escape') {
                closeModal();
            }
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isWebcamRunning) {
                logMessage('👁️ Tab hidden - pausing auto capture');
                if (captureInterval) {
                    clearInterval(captureInterval);
                    captureInterval = null;
                }
            } else if (!document.hidden && isWebcamRunning) {
                logMessage('👁️ Tab visible - resuming auto capture');
                startAutoCapture();
            }
        });

        // Handle window beforeunload
        window.addEventListener('beforeunload', () => {
            if (websocket) {
                websocket.close();
            }
            stopWebcam();
        });

        // Enhanced ping server with version info
        setInterval(() => {
            if (websocket && isConnected) {
                try {
                    websocket.send('ping');
                } catch (error) {
                    logMessage('Ping failed: ' + error.message, 'error');
                }
            }
        }, 30000); // Ping every 30 seconds

        // Safari-specific optimizations
        if (isSafari) {
            // Prevent Safari from caching too aggressively
            window.addEventListener('pageshow', function(event) {
                if (event.persisted) {
                    location.reload();
                }
            });
            
            // Handle Safari's stricter autoplay policies
            document.addEventListener('click', function() {
                if (webcamVideo && webcamVideo.paused && webcamStream) {
                    webcamVideo.play().catch(e => {
                        console.log('Video play failed:', e);
                    });
                }
            }, { once: true });
        }

        // Enhanced performance monitoring
        let performanceStats = {
            totalRequests: 0,
            avgYoloTime: 0,
            avgOcrTime: 0,
            avgTotalTime: 0,
            avgPreprocessTime: 0,
            stepVisualizationCount: 0
        };

        function updatePerformanceStats(yoloMs, ocrMs, totalMs, preprocessMs) {
            performanceStats.totalRequests++;
            
            // Calculate running averages
            const n = performanceStats.totalRequests;
            performanceStats.avgYoloTime = ((n - 1) * performanceStats.avgYoloTime + yoloMs) / n;
            performanceStats.avgOcrTime = ((n - 1) * performanceStats.avgOcrTime + ocrMs) / n;
            performanceStats.avgTotalTime = ((n - 1) * performanceStats.avgTotalTime + totalMs) / n;
            performanceStats.avgPreprocessTime = ((n - 1) * performanceStats.avgPreprocessTime + preprocessMs) / n;
            
            // Update UI every 10 requests
            if (n % 10 === 0) {
                logMessage(`📊 Performance (${n} requests): YOLO: ${performanceStats.avgYoloTime.toFixed(1)}ms, OCR: ${performanceStats.avgOcrTime.toFixed(1)}ms, Preprocess: ${performanceStats.avgPreprocessTime.toFixed(1)}ms`);
            }
        }

        // Initialize tooltips with enhanced descriptions
        function initializeTooltips() {
            const tooltips = {
                'yoloConfidence': 'Minimum confidence threshold for YOLO detections (0.1 = very sensitive, 1.0 = very strict)',
                'ocrConfidence': 'Minimum confidence threshold for OCR text recognition',
                'captureInterval': 'How often to automatically capture and process camera frames',
                'enableOCR': 'Enable or disable OCR text recognition processing',
                'enablePreprocessing': 'Enable advanced image preprocessing including CLAHE and filtering',
                'enableRotationCorrection': 'Enable text orientation correction using Hough line transform',
                'enableDebugMode': 'Enable detailed step-by-step visualization of the processing pipeline'
            };
            
            Object.entries(tooltips).forEach(([id, text]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.title = text;
                }
            });
        }

        // Network status monitoring
        window.addEventListener('online', function() {
            logMessage('🌐 Network connection restored', 'success');
            if (!isConnected && websocket === null) {
                setTimeout(() => connect(), 1000);
            }
        });

        window.addEventListener('offline', function() {
            logMessage('🌐 Network connection lost', 'error');
        });

        // Auto-expand first detection when steps are available
        function autoExpandFirstDetection() {
            setTimeout(() => {
                const firstDetectionSteps = document.getElementById('detection-steps-0');
                if (firstDetectionSteps && !firstDetectionSteps.classList.contains('expanded')) {
                    toggleDetectionSteps(0);
                    logMessage('🔍 Auto-expanded first detection for detailed view');
                }
            }, 500);
        }

        // Call initialization functions
        document.addEventListener('DOMContentLoaded', function() {
            initializeTooltips();
            
            // Add some enhanced example text to help users get started
            setTimeout(() => {
                if (!isConnected) {
                    logMessage('💡 Enhanced YOLO+OCR Pipeline v2.0 - Features:');
                    logMessage('🎯 Linear transformation perspective correction');
                    logMessage('✨ Step-by-step preprocessing visualization');
                    logMessage('🔄 Advanced rotation correction with Hough transforms');
                    logMessage('🤖 Multi-engine OCR (EasyOCR + Tesseract)');
                    logMessage('🔍 Enable debug mode in settings for detailed step images');
                    logMessage('⌨️ Keyboard shortcuts: Ctrl+U (upload), Ctrl+W (camera), Space (connect), 1-4 (tabs)');
                    if (isSafari) {
                        logMessage('🍎 Safari users: Allow camera permissions when prompted');
                    }
                }
            }, 2000);
        });

        // Mobile/touch optimizations
        if ('ontouchstart' in window) {
            // Add touch-friendly interactions
            document.addEventListener('touchstart', function() {
                // Enable video playback on touch devices
                if (webcamVideo && webcamVideo.paused && webcamStream) {
                    webcamVideo.play().catch(console.log);
                }
            }, { once: true });

            // Handle touch gestures for step navigation
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', function(e) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            document.addEventListener('touchend', function(e) {
                if (!touchStartX || !touchStartY) {
                    return;
                }

                let touchEndX = e.changedTouches[0].clientX;
                let touchEndY = e.changedTouches[0].clientY;

                let diffX = touchStartX - touchEndX;
                let diffY = touchStartY - touchEndY;

                // If swipe is primarily horizontal and significant
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 100) {
                    // Swipe left - next tab
                    if (diffX > 0) {
                        const tabs = ['steps', 'ocr', 'settings', 'logs'];
                        const current = document.querySelector('.tab-btn.active');
                        const currentIndex = Array.from(document.querySelectorAll('.tab-btn')).indexOf(current);
                        if (currentIndex < tabs.length - 1) {
                            switchTab(tabs[currentIndex + 1]);
                        }
                    }
                    // Swipe right - previous tab
                    else {
                        const tabs = ['steps', 'ocr', 'settings', 'logs'];
                        const current = document.querySelector('.tab-btn.active');
                        const currentIndex = Array.from(document.querySelectorAll('.tab-btn')).indexOf(current);
                        if (currentIndex > 0) {
                            switchTab(tabs[currentIndex - 1]);
                        }
                    }
                }

                touchStartX = 0;
                touchStartY = 0;
            });
        }

        // Image lazy loading for step images
        function setupLazyLoading() {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        if (img.dataset.src) {
                            img.src = img.dataset.src;
                            img.removeAttribute('data-src');
                            observer.unobserve(img);
                        }
                    }
                });
            });

            document.querySelectorAll('img[data-src]').forEach(img => {
                imageObserver.observe(img);
            });
        }

        // Auto-scroll to new processing steps
        function scrollToNewSteps() {
            const processingSteps = document.getElementById('processingsteps');
            if (processingSteps) {
                processingSteps.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'nearest' 
                });
            }
        }

        // Enhanced error handling with retry mechanism
        function handleWebSocketError(error) {
            console.error('WebSocket error:', error);
            
            // Attempt to reconnect after a delay
            if (isConnected) {
                logMessage('🔄 Connection lost. Attempting to reconnect in 3 seconds...', 'error');
                setTimeout(() => {
                    if (!isConnected) {
                        logMessage('🔄 Attempting reconnection...');
                        connect();
                    }
                }, 3000);
            }
        }

        // Export processing steps data
        function exportProcessingSteps() {
            if (!currentProcessingSteps || Object.keys(currentProcessingSteps).length === 0) {
                logMessage('No processing steps to export', 'error');
                return;
            }

            const exportData = {
                timestamp: new Date().toISOString(),
                version: '2.0',
                processing_steps: currentProcessingSteps,
                client_info: {
                    user_agent: navigator.userAgent,
                    screen_resolution: `${screen.width}x${screen.height}`,
                    browser: isSafari ? 'Safari' : 'Other'
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `processing_steps_${Date.now()}.json`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            logMessage('📁 Processing steps data exported', 'success');
        }

        // Context menu for step images
        document.addEventListener('contextmenu', function(e) {
            if (e.target.classList.contains('step-image') && e.target.tagName === 'IMG') {
                e.preventDefault();
                
                const menu = document.createElement('div');
                menu.style.cssText = `
                    position: fixed;
                    top: ${e.clientY}px;
                    left: ${e.clientX}px;
                    background: white;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    padding: 8px 0;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    z-index: 1000;
                    font-size: 14px;
                `;
                
                const openItem = document.createElement('div');
                openItem.textContent = '🔍 View Full Size';
                openItem.style.cssText = 'padding: 8px 16px; cursor: pointer; hover: background: #f0f0f0;';
                openItem.onclick = () => {
                    e.target.click();
                    document.body.removeChild(menu);
                };
                
                const downloadItem = document.createElement('div');
                downloadItem.textContent = '💾 Download Image';
                downloadItem.style.cssText = 'padding: 8px 16px; cursor: pointer; hover: background: #f0f0f0;';
                downloadItem.onclick = () => {
                    const link = document.createElement('a');
                    link.href = e.target.src;
                    link.download = `step_image_${Date.now()}.jpg`;
                    link.click();
                    document.body.removeChild(menu);
                };
                
                menu.appendChild(openItem);
                menu.appendChild(downloadItem);
                document.body.appendChild(menu);
                
                // Remove menu on click elsewhere
                setTimeout(() => {
                    document.addEventListener('click', function removeMenu() {
                        if (document.body.contains(menu)) {
                            document.body.removeChild(menu);
                        }
                        document.removeEventListener('click', removeMenu);
                    });
                }, 100);
            }
        });

        // Final initialization
        window.addEventListener('load', function() {
            logMessage('🎉 Enhanced YOLO+OCR Pipeline v2.0 client fully loaded and ready!');
            
            // Auto-connect if URL is provided and looks valid
            const serverUrl = document.getElementById('serverUrl').value;
            if (serverUrl && serverUrl.startsWith('ws://') && !isConnected) {
                logMessage('🔄 Auto-connecting to server...');
                setTimeout(connect, 1000);
            }
        });
    </script>
</body>
</html>